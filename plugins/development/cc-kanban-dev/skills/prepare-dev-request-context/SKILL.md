---
name: prepare-dev-request-context
description: Before implementing a user's development request (new feature, modification, or requirement), gather or confirm context so the AI can implement it correctly. Use when the user describes what they want done (e.g. "加个导出功能", "修改登录逻辑", "支持多看板") rather than a pinpoint code edit.
version: 0.1
---

# 开发需求前的上下文准备

当用户提出的是**开发需求**（新功能、修改、任意「要做什么」）而非「改某一行」时，先补充以下上下文再动手实现，可显著减少返工和误解。

## 何时使用本流程

- 用户用自然语言描述目标（如「支持卡片拖到别的列」「加一个项目筛选」）
- 需求可能涉及多文件、多层级（前端 + IPC + 数据库）
- 实现路径不唯一，需要先确定范围与约束

若用户已明确指定文件与具体改动方式，可直接执行，不必强行走完清单。

---

## 实现前需确认或补充的上下文

### 1. 范围与影响面

| 问题 | 目的 |
|------|------|
| 影响哪些端？ | 仅前端 / 仅主进程 / 前后端 + IPC + DB |
| 涉及哪些模块？ | 看板、卡片、列、项目、设置等 |
| 是否只读现有代码即可，还是要改 schema/API？ | 决定是否要看 db、ipc、api.ts |

**做法**：根据需求关键词（如「看板」「卡片」「项目」「导出」「打开路径」）在项目中定位相关目录与入口（如 `src/renderer/`、`src/main/ipc.ts`、`db/schema.sql`），再决定要读哪些文件。

### 2. 现有行为与入口

- **相关代码在哪**：通过语义搜索或 grep 找到与需求相关的组件、API、IPC、表结构。
- **当前逻辑是什么**：先读懂「现在是怎么做的」，再设计「要改成怎样」，避免误伤现有功能。

**做法**：先搜再读。例如需求是「卡片可编辑」→ 找 `CardItem`、`update-card`、`updateCard`；需求是「按项目筛选」→ 找 `projects`、`project_id`、看板/卡片列表的取数逻辑。

### 3. 约束与约定

- **技术栈与规范**：本项目用 React + TypeScript、antd、Zustand、@dnd-kit、Electron、SQLite；UI 用 antd，不引入新 UI 库；见项目根目录的 `CLAUDE.md`。
- **数据与 API**：类型以 `api.ts` 为准；新增能力需在 `ipc.ts` 注册、在 `api.ts` 暴露；主进程负责 DB 与文件访问。
- **不破坏的现有功能**：例如拖拽、多列、项目侧栏、打开路径等；改动的文件列表要心里有数，避免无心改坏无关逻辑。

**做法**：实现前快速扫一眼 `CLAUDE.md` 的「技术栈」「目录结构」「数据流与 IPC」「开发与修改约定」。

### 4. 验收标准与边界

- **完成标准**：用户说的「完成」具体指什么？（例如「能点保存并刷新列表」）
- **边界情况**：空列表、无权限、路径不存在、网络/本地失败等要不要处理？
- **是否要写/跑测试**：若项目有测试，改动是否需补测或跑现有用例？

**做法**：若需求一句话带过（如「加个导出」），在回复中简短列出你的理解（导出什么、格式、从哪触发），并注明「若需要别的格式或入口可以再说」；若用户已写清验收标准，可直接按标准实现。

---

## 推荐工作流

1. **解析需求**：用一句话复述「要做什么」和「影响哪一块」。
2. **定位代码**：根据上表 1、2 搜索并列出将要阅读或修改的文件/符号。
3. **快速阅读**：只读与本次改动强相关的部分（不必通读全库）；必要时参考 `CLAUDE.md` 的约定。
4. **补全约束**：确认技术栈、IPC/类型、不破坏的现有行为；若缺验收标准，可简要写出你的理解并开始实现。
5. **实现与自检**：按约定改代码；改完后自检是否影响拖拽、列表、项目等已有能力。

---

## 示例：需求过简时如何补上下文

**用户**：「加个导出功能。」

**可先补的上下文（内心或回复中明确）：**

- **范围**：导出的是「当前看板」还是「所有看板」？是卡片列表还是含列结构？→ 决定是否只读 `boards/cards/columns` 与 store。
- **格式**：JSON / CSV / Markdown？→ 决定在前端生成还是在主进程写文件。
- **入口**：菜单、看板头部的按钮、还是设置页？→ 决定在哪个组件加 UI。
- **约束**：遵循现有 IPC 与 antd 组件；若写文件走主进程，需新增 IPC（如 `export-board`）。

补全后再实现：先加 IPC（若需要），再在前端加按钮与导出逻辑，避免做到一半发现漏了主进程或格式不对。

---

## 小结

- **先范围、再定位、再读码、再约束、再实现**。
- 需求越模糊，越要在动手前用「范围 / 现有行为 / 约束 / 验收」过一遍；需求越具体，可适当缩短清单，但仍建议先定位相关代码再改。
